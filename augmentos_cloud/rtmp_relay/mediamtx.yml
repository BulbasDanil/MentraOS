# MediaMTX configuration for RTMP relay
# This accepts "dirty" streams from glasses and cleans them for Cloudflare

logLevel: info
logDestinations: [stdout]

# API for health checks and monitoring
api:
  address: :9997

# RTMP server configuration
rtmp:
  address: :1935
  readTimeout: 10s
  writeTimeout: 10s

# Path configuration for incoming streams
paths:
  # Accept streams at: rtmp://relay-host:1935/live/{userId}/{streamId}
  live/(.+)/(.+):
    source: publisher
    sourceProtocol: rtmp
    
    # When a stream starts, transcode and forward to Cloudflare
    runOnPublish: |
      #!/bin/bash
      set -e
      
      USER_ID=$1
      STREAM_ID=$2
      
      echo "Stream published: userId=$USER_ID streamId=$STREAM_ID"
      
      # Get Cloudflare URL from our API
      RESPONSE=$(curl -s "$CLOUD_API_URL/api/rtmp-relay/cf-url/$USER_ID/$STREAM_ID")
      CF_URL=$(echo "$RESPONSE" | grep -o '"url":"[^"]*' | grep -o '[^"]*$')
      
      if [ -z "$CF_URL" ]; then
        echo "ERROR: Could not get Cloudflare URL for stream"
        exit 1
      fi
      
      echo "Forwarding to Cloudflare: $CF_URL"
      
      # Transcode with FFmpeg to clean the stream
      # - Force output to 30fps (duplicates frames if input is lower)
      # - Force consistent GOP (60 frames = 2 seconds at 30fps)
      # - Ensure mono audio
      # - Set consistent bitrate
      # - Use baseline profile for compatibility
      exec ffmpeg -i rtmp://localhost:1935/$RTMP_PATH \
        -c:v libx264 -preset veryfast -tune zerolatency \
        -profile:v baseline -level 3.1 \
        -r 30 -g 60 -keyint_min 60 -sc_threshold 0 \
        -b:v 2M -maxrate 2.5M -bufsize 4M \
        -pix_fmt yuv420p \
        -c:a aac -ar 44100 -ac 1 -b:a 128k \
        -f flv "$CF_URL" \
        -loglevel info
        
    runOnPublishRestart: yes
    
    # Optional: Log when streams stop
    runOnUnpublish: |
      #!/bin/bash
      echo "Stream unpublished: $RTMP_PATH"